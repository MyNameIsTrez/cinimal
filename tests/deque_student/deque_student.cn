import { assert } from <assert.h>
import { f64, i32 } from <stdint.h>
import { calloc, free } from <stdlib.h>
import { memcpy } from <string.h>

struct student
	age: f64

struct deque_student
	data: ptr student
	start_index: i32
	size: i32
	capacity: i32

pub deque_student new()
	deque: mut deque_student
	deque = 0
	deque.data = calloc(1, student)
	deque.capacity = 1

	return deque

void try_grow(deque: ptr mut deque_student)
	if deque*.size == deque*.capacity
		deque*.capacity *= 2

		new_data: ptr mut student
		new_data = calloc(deque*.capacity, student)

		# An example ring buffer is [B,C, ,A], where the start_index is 3
		trailing: mut i32
		trailing = deque*.capacity - deque*.start_index

		# This copies the part that wrapped below index 0 to the other side
		memcpy(new_data, deque*.data + deque*.start_index, trailing)
		# This copies from index 0 on
		memcpy(new_data + trailing, deque*.data, deque*.size - trailing)

		free(deque*.data)
		deque*.data = new_data

		deque*.start_index = 0

pub void push_front(deque: ptr mut deque_student, student: student)
	try_grow(deque)

	deque*.start_index = (deque*.start_index - 1) % deque*.capacity
	deque*.data[deque*.start_index] = student

	deque*.size++

pub ptr student back(deque: ptr mut deque_student)
	return deque*.data + get_back_index(deque)

pub void push_back(deque: ptr mut deque_student, student: student)
	try_grow(deque)

	deque*.data[get_back_index(deque)] = student

	deque*.size++

i32 get_back_index(deque: ptr mut deque_student)
	return (deque*.start_index + deque*.size) % deque*.capacity

pub void student pop_front(deque: ptr mut deque_student)
	deque*.start_index++
	deque*.size--

pub void student pop_back(deque: ptr mut deque_student)
	deque*.size--

i32 main()
	deque: mut deque_student
	deque = deque_student::new()

	alice: mut student
	alice = 0
	alice.age = 10
	deque_student::push_back(&deque, alice)

	bob: mut student
	bob = 0
	bob.age = 11
	deque_student::push_back(&deque, bob)

	charles: mut student
	charles = 0
	charles.age = 9
	deque_student::push_front(&deque, charles)

	assert(deque.data[0].age == 9)
	assert(deque.data[1].age == 10)
	assert(deque.data[2].age == 11)

	assert(deque_student::pop_front(&deque).age == 9)
	assert(deque_student::pop_back(&deque).age == 11)

	return 0
