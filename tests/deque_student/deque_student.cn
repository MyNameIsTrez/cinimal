import { assert } from <assert.h>
import { f64, i32 } from <stdint.h>
import { calloc, free } from <stdlib.h>
import { memcpy } from <string.h>

struct student
	f64 age

struct deque_student
	ptr student data
	i32 start_index
	i32 size
	i32 capacity

pub deque_student new()
	mut deque_student deque
	deque = 0
	deque.data = calloc(1, student)
	deque.capacity = 1

	return deque

void try_grow(ptr mut deque_student deque)
	if deque*.size == deque*.capacity
		deque*.capacity *= 2

		ptr mut student new_data
		new_data = calloc(deque*.capacity, student)

		# An example ring buffer is [B,C, ,A], where the start_index is 3
		mut i32 trailing
		trailing = deque*.capacity - deque*.start_index

		# This copies the part that wrapped below index 0 to the other side
		memcpy(new_data, deque*.data + deque*.start_index, trailing)
		# This copies from index 0 on
		memcpy(new_data + trailing, deque*.data, deque*.size - trailing)

		free(deque*.data)
		deque*.data = new_data

		deque*.start_index = 0

pub void push_front(ptr mut deque_student deque, student student)
	try_grow(deque)

	deque*.start_index = (deque*.start_index - 1) % deque*.capacity
	deque*.data[deque*.start_index] = student

	deque*.size++

pub ptr student back(ptr mut deque_student deque)
	return deque*.data + get_back_index(deque)

pub void push_back(ptr mut deque_student deque, student student)
	try_grow(deque)

	deque*.data[get_back_index(deque)] = student

	deque*.size++

i32 get_back_index(ptr mut deque_student deque)
	return (deque*.start_index + deque*.size) % deque*.capacity

pub void student pop_front(ptr mut deque_student deque)
	deque*.start_index++
	deque*.size--

pub void student pop_back(ptr mut deque_student deque)
	deque*.size--

i32 main()
	mut deque_student deque
	deque = deque_student::new()

	mut student alice
	alice = 0
	alice.age = 10
	deque_student::push_back(&deque, alice)

	mut student bob
	bob = 0
	bob.age = 11
	deque_student::push_back(&deque, bob)

	mut student charles
	charles = 0
	charles.age = 9
	deque_student::push_front(&deque, charles)

	assert(deque.data[0].age == 9)
	assert(deque.data[1].age == 10)
	assert(deque.data[2].age == 11)

	assert(deque_student::pop_front(&deque).age == 9)
	assert(deque_student::pop_back(&deque).age == 11)

	return 0
