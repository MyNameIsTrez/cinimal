import { assert } from <assert.h>
import { f64, i32 } from <stdint.h>
import { calloc, free } from <stdlib.h>
import { memcpy } from <string.h>

struct Student
	age: f64

struct Fruit
	name: ptr char

struct Deque
	elements: ptr u8
	type_size: i32
	start_index: i32
	size: i32
	capacity: i32

pub deque_new(type_size: i32): Deque
	deque: mut Deque
	deque = {}
	deque.elements = calloc(1, type_size)
	deque.type_size = type_size
	deque.capacity = 1

	return deque

pri try_grow(deque: ptr mut Deque)
	if deque.size == deque.capacity
		new_elements: ptr mut u8
		new_elements = calloc(deque.capacity * 2, deque.type_size)

		# An example deque is [B,C, ,A], where the start_index is 3
		trailing: mut i32
		trailing = deque.capacity - deque.start_index

		# Copies everything to the right of the unused elements
		memcpy(
			new_elements,
			deque.elements + deque.start_index * deque.type_size,
			trailing * deque.type_size
		)

		# Copies everything to the left of the unused elements
		memcpy(
			new_elements + trailing * deque.type_size,
			deque.elements,
			(deque.size - trailing) * deque.type_size
		)

		free(deque.elements)
		deque.elements = new_elements

		deque.start_index = 0
		deque.capacity *= 2

pri modulo(a: i32, b: i32): i32
    # TODO: Can be done more efficiently
    return ((a % b) + b) % b

pri assign_element(deque: ptr Deque, element: ptr u8, index: i32)
	memcpy(deque.elements + index * deque.type_size, element, deque.type_size)

pub deque_push_front(deque: ptr mut Deque, element: ptr u8)
	try_grow(deque)

	deque.start_index = modulo(deque.start_index - 1, deque.capacity)
	assign_element(deque, element, deque.start_index)

	deque.size++

pub deque_push_back(deque: ptr mut Deque, element: ptr u8)
	try_grow(deque)

    index: i32
    index = (deque.start_index + deque.size) % deque.capacity
	assign_element(deque, element, index)

	deque.size++

pub deque_front(deque: ptr mut Deque): ptr u8
	return deque.elements + deque.start_index * deque.type_size

pub deque_back(deque: ptr mut Deque): ptr u8
    # TODO: Does this handle size=0 properly?
    index: i32
    index = (deque.start_index + deque.size - 1) % deque.capacity
	return deque.elements + index * deque.type_size

pub deque_pop_front(deque: ptr mut Deque)
	deque.start_index = (deque.start_index + 1) % deque.capacity
	deque.size--

pub deque_pop_back(deque: ptr mut Deque)
	deque.size--

pub deque_at(deque: ptr Deque, index: i32): ptr thing
    return deque.elements + index * deque.type_size

pub deque_delete(deque: ptr mut Deque)
	free(deque.elements)

pub main(): i32
	deque: mut Deque
	deque = deque_new(Student)

	alice: mut Student
	alice = {}
	alice.age = 10
	deque_push_back(&deque, &alice)

	bob: mut Student
	bob = {}
	bob.age = 11
	deque_push_back(&deque, &bob)

	charles: mut Student
	charles = {}
	charles.age = 9
	deque_push_front(&deque, &charles)

	student: mut ptr Student

    student = deque_at(&deque, 3)
	assert(student->age == 9)
    student = deque_at(&deque, 0)
	assert(student->age == 10)
    student = deque_at(&deque, 1)
	assert(student->age == 11)

    student = deque_front(&deque)
	assert(student.age == 9)
	deque_pop_front(&deque)

    student = deque_back(&deque)
	assert(student.age == 11)
	deque_pop_back(&deque)

	deque_delete(&deque)

	deque = deque_new(Fruit)
	Fruit apple
	apple.name = "apple"
	deque_push_back(&deque, (ptr u8)&apple)
	assert(((ptr Fruit)deque_back(&deque)).name == "apple")
	deque_delete(&deque)

	return 0
