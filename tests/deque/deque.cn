import { assert } from <assert.h>
import { f64, i32 } from <stdint.h>
import { calloc, free } from <stdlib.h>
import { memcpy } from <string.h>

struct Student
	age: f64

struct Fruit
	name: ptr char

struct Deque
	elements: ptr u8
	type_size: i32
	start_index: i32
	size: i32
	capacity: i32

pub deque_new(type_size: i32): Deque
	deque: mut Deque
	deque = {}
	deque.elements = calloc(1, type_size)
	deque.type_size = type_size
	deque.capacity = 1

	return deque

pub deque_reserve(deque: ptr mut Deque, new_capacity: i32)
	if deque.size == deque.capacity
		new_elements: ptr mut u8
		new_elements = calloc(new_capacity, deque.type_size)

		# An example deque is [B,C, ,A], where the start_index is 3
		trailing: mut i32
		trailing = deque.capacity - deque.start_index

		# Copies everything to the right of the unused elements
		memcpy(
			new_elements,
			deque.elements + deque.start_index * deque.type_size,
			trailing * deque.type_size
		)

		# Copies everything to the left of the unused elements
		memcpy(
			new_elements + trailing * deque.type_size,
			deque.elements,
			(deque.size - trailing) * deque.type_size
		)

		free(deque.elements)
		deque.elements = new_elements

		deque.start_index = 0
		deque.capacity = new_capacity

pri modulo(a: i32, b: i32): i32
    # TODO: Can be done more efficiently
    return ((a % b) + b) % b

pub deque_set(deque: ptr Deque, element: ptr thing, index: i32)
	memcpy(deque.elements + index * deque.type_size, element, deque.type_size)

pub deque_push_front(deque: ptr mut Deque, element: ptr thing)
	if deque.size == deque.capacity
		deque_reserve(deque, deque.capacity * 2)

	deque.start_index = modulo(deque.start_index - 1, deque.capacity)
	deque_set(deque, element, deque.start_index)

	deque.size++

pub deque_push_back(deque: ptr mut Deque, element: ptr thing)
	if deque.size == deque.capacity
		deque_reserve(deque, deque.capacity * 2)

    index: i32
    index = (deque.start_index + deque.size) % deque.capacity
	deque_set(deque, element, index)

	deque.size++

pub deque_front(deque: ptr mut Deque): ptr thing
	return deque.elements + deque.start_index * deque.type_size

pub deque_back(deque: ptr mut Deque): ptr thing
    # TODO: Does this handle size=0 properly?
    index: i32
    index = (deque.start_index + deque.size - 1) % deque.capacity
	return deque.elements + index * deque.type_size

pub deque_pop_front(deque: ptr mut Deque)
	deque.start_index = (deque.start_index + 1) % deque.capacity
	deque.size--

pub deque_pop_back(deque: ptr mut Deque)
	deque.size--

pub deque_at(deque: ptr Deque, index: i32): ptr thing
    return deque.elements + index * deque.type_size

pub deque_delete(deque: ptr mut Deque)
	free(deque.elements)

pub main(): i32
	deque: mut Deque
	deque = deque_new(Student)

	alice: mut Student
	alice = {10}
	deque_push_back(&deque, &alice)

	bob: mut Student
	bob = {11}
	deque_push_back(&deque, &bob)

	charles: mut Student
	charles = {9}
	deque_push_front(&deque, &charles)

	student: mut ptr Student

    student = deque_at(&deque, 3)
	assert(student->age == 9)
    student = deque_at(&deque, 0)
	assert(student->age == 10)
    student = deque_at(&deque, 1)
	assert(student->age == 11)

    student = deque_front(&deque)
	assert(student.age == 9)
	deque_pop_front(&deque)

    student = deque_back(&deque)
	assert(student.age == 11)
	deque_pop_back(&deque)

	deque_delete(&deque)

	deque = deque_new(Fruit)
	deque_reserve(&deque, 100)

	Fruit apple
	apple.name = "apple"
	deque_push_back(&deque, &apple)
	deque_set(&deque, &(Fruit){"banana"}, 0);
	assert(((ptr Fruit)deque_back(&deque)).name == "banana")

	deque_delete(&deque)

	return 0
